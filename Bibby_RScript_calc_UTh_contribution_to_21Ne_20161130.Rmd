```{r setup,include=FALSE}
#supress written code from displaying in html document
knitr::opts_chunk$set(echo=FALSE,warning = FALSE)
```

```{r}
#Remove all lists
rm(list=ls())
```
#Document Summary:
To import U and Th data from Dan, calculate the background 21Ne expected based on those concentrations, and compare it to measured concentrations from NGMS
```{r, message=FALSE, }
#Load libraries
library(tidyverse)
library(stringr)
library(DT)
library(knitr)
library(stringi)
library(ggplot2)
```

#Calculate background 21Ne from U and Th concentrations in quartz
Read original data csv from Dan Morgan

```{r}
#Open path on Mac
my_data <- tbl_df(read.csv("~/Box Sync/Research/!active_projects/U-Th_in_Ne-21/data_original/GeochemistryDataAntML2015.csv" , stringsAsFactors = FALSE)) %>%
  rename(sample_id = ANALYTE, wtkg = WtKg)
datatable(my_data)

# #Open path on PC:
# my_data <- tbl_df(read.csv("C:\\Users\\Geomorph\\Box Sync\\Research\\!active_projects\\U-Th_in_Ne-21\\data_original\\GeochemistryDataAntML2015.csv" , stringsAsFactors = FALSE)) %>% 
#   rename(sample_id = ANALYTE, wtkg = WtKg)
# datatable(my_data)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##Import measured 21Ne concentrations from BGC
#File named: Morgan_MonoBasin_Pebbles_Ne21_clean.csv 

# Load file path name on mac
bgc_data <- tbl_df(read.csv("~/Box Sync/Research/!active_projects/U-Th_in_Ne-21/data_cleaned_b4_import/Morgan_MonoBasin_Pebbles_Ne21_clean.csv" , stringsAsFactors = FALSE))

## Load file path name on PC
# bgc_data <- tbl_df(read.csv("C:\\Users\\Geomorph\\Box Sync\\Research\\!active_projects\\U-Th_in_Ne-21\\data_cleaned_b4_import\\Morgan_MonoBasin_Pebbles_Ne21_clean.csv" , stringsAsFactors = FALSE)) 

#create column names and output a data table
colnames(bgc_data) <- tolower(colnames(bgc_data))
datatable(bgc_data)
```

We need to remove special characters from data and adjust headers so every row is an observation and every column is a category

```{r}
#set row names to sample ID's

#get meta data from csv cells
header_names <- my_data$sample_id[1:3]
meta = my_data %>% 
  filter(sample_id %in% header_names)

# take my_data, call it true_data
true_data <- my_data %>% 
  filter(!(sample_id %in% header_names)) %>% 
  as_data_frame() %>% 
  gather(element, ppm, -sample_id,-wtkg) %>% 
  mutate(numeric_ppm = as.numeric(ppm),
         wtkg = as.numeric(wtkg), 
         below_limit_ppm = str_detect(ppm,"<")) %>%
  arrange((sample_id)) 

true_data %>% 
  arrange(sample_id) %>% 
  datatable()
```

Constants:
These need to be double checked and confirmed with citeable online source.

```{r}
#Analytical Resuts
sampleAge = 100e6 #Ma

#Standards and Constants
U238_abundance = 0.992742
U235_abundance = 0.007204
Th232_abundance = 1
abundance = c(U238_abundance,U235_abundance,Th232_abundance)
#names(abundance)<- elements

#Isotope constants
U238_mass= 238.050788247
U235_mass = 235.043929918
Th232_mass = 232.038055325
mass = c(U238_mass,U235_mass,Th232_mass)
#names(mass)<- elements

#Number of alpha decays for the radioactive reaction series. (online)
U238_num_alphas = 8
U235_num_alphas = 7
Th232_num_alphas = 6
num_alpha_decays_in_chain = c(U238_num_alphas,U235_num_alphas,Th232_num_alphas)
#names(num_alphas)<-elements

avogadro= 6.022E23

#Nucleogenic Neon Production Rates
U238_21Ne_Prate = 4.04E-8 #via Table 6, Coxx et al 2015
U235_21Ne_Prate = 5.62E-8 #via Table 6, Coxx et al 2015
Th232_21Ne_Prate = 6.08E-8 #via Table 6, Coxx et al 2015
ne21_nucleogenic_P_rate = c(U238_21Ne_Prate,U235_21Ne_Prate,Th232_21Ne_Prate)
#names(Ne21_Nucl_Prate)<- elements


#Alpha Decay Constants "lambda"= ln(2)/T_halflife (confirmed 09/21/2016)
U238_alpha = log(2)/4.468E9
U235_alpha = log(2)/7.038E8
Th232_alpha = log(2)/1.405E10
lambda = c(U238_alpha,U235_alpha,Th232_alpha)
#names(lambda)<- elements

# Create a data frame of the constants
elem_info=data_frame(element=c("U","U","Th"),isotope=c("U238","U235","Th232"),abundance,
mass,num_alpha_decays_in_chain,ne21_nucleogenic_P_rate,lambda)

datatable(elem_info)
```

Separate U and Th into their respective isotopes:
Coxx et al provides neon prodution rates as a function of U235, U238, and Th232. This means we need to normalize the measured ppm of U and Th to their respective abundances before proceeding. As an example, if our measured total U concentraion is 100 ppm, and the abundance of U235 is 1% and U238 is 99%, we expect that in our sample, of 100ppm, 1ppm is U235 and the remaining 99ppm is U238. These get summed at the end to calculate toal Ne21.

```{r}
#-----write a function to split elements into isotopes U235 and U238-------------
#so we can create a big ole data frame in which to do parrallel math across rows

elements <- unique(true_data$element)

atom_splitter=function(i, dat, elem_info){
  
  tdat <- dat %>% 
    filter(element == i) %>% 
    mutate(isotope = NA,
           iso_ppm = numeric_ppm,
           isoprop = 1)
  
  isos <- elem_info %>% 
    filter(element == i)
  
  if (dim(isos)[1] > 0){
    
    props <- rep(isos$abundance,length(unique(tdat$sample_id)))
    
    isotopes <-  rep(isos$isotope,length(unique(tdat$sample_id)))
      
    tdat <- tdat[rep(1:dim(tdat)[1], length(isos$isotope)),] %>% 
      arrange(sample_id) %>% 
      mutate(isoprop = props, 
             iso_ppm = numeric_ppm * isoprop,
             isotope = isotopes)
    
  }
  
  return(tdat)
}

extended_elements <- lapply(elements, atom_splitter, dat = true_data, elem_info = elem_info) %>% 
  bind_rows()

extended_elements %>% 
  select(sample_id,element,isotope,isoprop,numeric_ppm,iso_ppm) %>%
  filter(element %in%c("U","Th") ) %>% 
  arrange(sample_id) %>% 
  datatable()
```

For simplicty and math sake we merge our data and constants into a single dataframe.

```{r}
#So first get everything in a single
#merge the two df's based on common obervation known as isotope
extended_elements=full_join(extended_elements,elem_info,by="isotope")
#format a clean dataframe
extended_elements=tbl_df(extended_elements)

#ok! now we have a big clean data set in which to do cross math with!
#BUT... need to add other constants like avogadro and sample age
extended_elements=mutate(extended_elements, avogadro,sampleAge)

extended_elements %>% 
  arrange(sample_id) %>% 
  datatable()
```

##Now we're ready to do some calculations
####Parent Atoms
Calculate the number of original parent atoms of U and Th based on the measured concentration of each element.

Formula: parent_atoms = (numeric_ppm/1E6)*wtkg*1000*abundance*(1/mass)*avogadro)

```{r}
# Ok so the data is all there finally, now do some math across columns
#filter entries that don't have isotope abundances since you can't so math on "NA's"

extended_elements=extended_elements %>% 
  filter(is.na(abundance)==FALSE ) %>% 
  mutate(parent_atoms = (numeric_ppm/1E6)*wtkg*1000*abundance*(1/mass)*avogadro) %>% 
  as_data_frame()

#Plot Parent atoms/sample
extended_elements %>% 
  ggplot(aes(x=sample_id,y=parent_atoms, color=isotope))+
  geom_point()+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))+
  ggtitle("Parent atoms")+
  ylab("Parent atoms (n)")
```

####Alpha decays
How many radioactive alpha decays have occurred during the lifetime of the sample? This is based on the age of the sample, the original concentration of parent isotopes, and the 1/2 life of the isotope.

Formula: alpha_decays = parent_atoms*(exp(lambda*sampleAge)-1)
```{r}
extended_elements=extended_elements %>% 
  mutate(alpha_decays = parent_atoms*(exp(lambda*sampleAge)-1))

#Plot decays/sample
extended_elements %>% 
  ggplot(aes(x=sample_id,y=alpha_decays, color=isotope))+
  geom_point()+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))+
  ggtitle("Alpha Decays")+
  ylab("Alpha decays (n)")
```

#### Alpha particles
Since we know how many radioactive alpha decays have occured from the parent atom of each sample, we can calculate the number of alpha particles that have been emitted in the crystal lattice for the lifetime of the sample.This is important because it's the emission of an alpha particle which then interacts with an oxygen isotope in quartz to form 21Ne. The number of ejected alpha particles is based on the number of alpha decays that occur in the parent isotope during the decay process. If you look at the Thorium series decay chain (or decay path), you'll see that there are 6 alpha particles emited.[https://en.wikipedia.org/wiki/Decay_chain]
Thus, we are just multiplying the number of radioactive decays that have occurred times the number of alpha particles emitted for each radioactive decay to get the total number of alpha particles that can smash into oxygen isotopes to form 21Ne.

Formula:alpha_particles = num_alpha_decays_in_chain*alpha_decays
```{r}
extended_elements=extended_elements %>% 
  mutate(alpha_particles = num_alpha_decays_in_chain*alpha_decays)

#Plot alpha particles/decay
extended_elements %>% 
  ggplot(aes(x=alpha_particles,y=alpha_decays, color=isotope))+
  geom_point()+
  geom_smooth()+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))+
  ggtitle("# of alpha particles vs alpha decays")+
  xlab("# of alpha particles")+
  ylab("# of alpha decays")
```

#### Neon 21 from normal radioactive decay
So how much 21Ne is produced in-situ from normal radioactive decay of nearby U and Th? We are now relying on the total number of alpha particles we just calculated and the experimental results of Coxx et al for the production rate of Neon in quartz. Coxx et al blasted some pure quartz standards with an ion source and in their paper provide production rates in Table 6. So again we just need to multiply the number of total alpha particles ejected from U and Th by the "alpha based production rate or nucleogenic production rate" of 21Ne (atoms/alpha particle).

Formula: ne21_nucl_n_atoms = alpha_particles*ne21_nucleogenic_P_rate



```{r}
extended_elements=extended_elements %>% 
  mutate(ne21_nucl_n_atoms = alpha_particles*ne21_nucleogenic_P_rate)

#Plot dots
extended_elements %>% 
  ggplot(aes(y=ne21_nucl_n_atoms,x=numeric_ppm, color=isotope))+
  geom_point()+
  geom_smooth()+
  ggtitle("Nucleogenic 21Ne vs Th & U concentration")+
  ylab("Nucleogenic 21Ne (atoms)")+
  xlab("Concentration (ppm)")
```
Above: What are we learning here? As expected, the greater the concentration of U and Th, the greater the concentration of 21Ne. In the U series, U238 is the dominant producer of 21Ne but it is also 99% abundant (as compared to U235). There's something else here, but I can't put my finger on it. I go into it below.



```{r}
#Plot histogram showing the porportion of each isotope per sample
extended_elements %>% 
  ggplot(aes(x=sample_id,y=ne21_nucl_n_atoms,fill = isotope))+
  geom_bar(stat = "identity")+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))+
  ggtitle("Th & U fractions of Nucelogenic Neon by sample")+
  xlab("")+
  ylab("Nucleogenic 21Ne (atoms)")

```
Above: This histogram gives a clear picture of the impact of each element. But as I look at it closer there's something funny going on. On first pass, Th makes up over half of the nucleogenic neon. But in the pebble samples, U is responsible for the bulk of neon. Not sure why the ratio of Th:U is not the same for all samples. Maybe it depends on the amount (mass) of the sample measured? Or maybe it's a function of the concentration (ppm) in each sample?

We can compare this relationship of ppm to concentration using the previous plot. Maybe it's a slope issue? U has a steeper slope so at lower concentrations (ppm) it produces more neon than Th?

Lets do the same plot as above but highlight a few choice samples

```{r}
#Plot dots and highlight a couple samples with their names
extended_elements %>%
  filter(sample_id %in% c("10-MC-BR-19","10-MC-ERR-34","15-ML-18-Peb") ) %>% 
  ggplot(aes(y=ne21_nucl_n_atoms,x=numeric_ppm, color=isotope,shape = sample_id,label = sample_id))+
  #geom_text(check_overlap = FALSE)+
  geom_point()+
  geom_smooth()+
  ggtitle("Nucleogenic 21Ne vs Th & U concentration")+
  ylab("Nucleogenic 21Ne (atoms)")+
  xlab("Concentration (ppm)")
  
```


```{r}
extended_elements %>% 
  ggplot(aes(x=sample_id,y=ne21_nucl_n_atoms, color=isotope))+
  geom_point(aes(shape = isotope))+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))+
  ggtitle("Th & U fractions of Nucelogenic Neon by sample")+
  xlab("")+
  ylab("Nucleogenic 21Ne (atoms)")
  #scale_y_log10()
```
Same thing as above just dots



####Calculate atoms per gram qtz
```{r}
extended_elements= extended_elements %>% 
  mutate(ne21_atoms_per_gram = ne21_nucl_n_atoms/wtkg)


```


##




